---
phase: 03-comparison-charts-and-electrical-slider
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/data/processing.py
  - src/layout/charts.py
autonomous: true
requirements:
  - CHART-01
  - CHART-02
  - CHART-03
  - CHART-04
  - CHART-05
  - CTRL-01
  - VIS-03

must_haves:
  truths:
    - "compute_cost_over_time returns a cumulative cost numpy array for a given system DataFrame and year count"
    - "interpolate_battery_cost returns a float cost from continuous slider value against the 11-row lookup table"
    - "compute_chart_data returns all chart data for all three systems in a single dict"
    - "build_cost_chart returns a Plotly Figure with three system line traces showing cumulative cost"
    - "build_land_chart returns a grouped bar Figure comparing land area across systems"
    - "build_turbine_chart returns a grouped bar Figure comparing wind turbine counts"
    - "build_pie_chart returns a Figure with three side-by-side pie charts showing energy breakdown per system"
    - "make_chart_section returns a Dash layout with control panel, shared legend, and 2x2 chart grid"
  artifacts:
    - path: "src/data/processing.py"
      provides: "compute_cost_over_time, interpolate_battery_cost, compute_chart_data, battery_ratio_label"
      contains: "def compute_cost_over_time"
    - path: "src/layout/charts.py"
      provides: "build_cost_chart, build_land_chart, build_turbine_chart, build_pie_chart, make_chart_section"
      contains: "def make_chart_section"
  key_links:
    - from: "src/layout/charts.py"
      to: "src/data/processing.py"
      via: "import compute_chart_data, interpolate_battery_cost"
      pattern: "from src\\.data\\.processing import"
    - from: "src/layout/charts.py"
      to: "src/config.py"
      via: "import SYSTEM_COLORS"
      pattern: "from src\\.config import SYSTEM_COLORS"
---

<objective>
Build the data computation layer and all four chart figure-builder functions for Phase 3.

Purpose: Provides the pure-function foundation that the callback wiring plan (03-02) will connect to sliders and the UI. Separating data logic from callback wiring keeps each plan focused and under the context budget.

Output: Updated processing.py with chart data computation functions; new charts.py with four figure builders and the chart section layout component.
</objective>

<execution_context>
@C:/Users/kevin/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-comparison-charts-and-electrical-slider/03-CONTEXT.md
@.planning/phases/03-comparison-charts-and-electrical-slider/03-RESEARCH.md
@src/data/processing.py
@src/config.py
@src/layout/system_view.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add chart data computation functions to processing.py</name>
  <files>src/data/processing.py</files>
  <action>
Add the following functions to the END of src/data/processing.py (after the existing get_equipment_stage function). Keep all existing code untouched.

**1. `interpolate_battery_cost(battery_fraction: float, battery_lookup_df: pd.DataFrame) -> float`**
- Takes a float 0.0 (all tank) to 1.0 (all battery) and the battery_lookup DataFrame.
- Uses `numpy.interp()` against the "battery_fraction" and "total_cost" columns (both coerced to float via pd.to_numeric).
- Returns the interpolated total_cost as a float.
- Add `import numpy as np` at the top of the file (alongside existing imports).

**2. `battery_ratio_label(battery_fraction: float) -> str`**
- Returns a formatted string like "70% Battery / 30% Tank".
- `pct_batt = int(round(battery_fraction * 100))`, `pct_tank = 100 - pct_batt`.

**3. `compute_cost_over_time(df: pd.DataFrame, years: int = 50, override_costs: dict | None = None) -> np.ndarray`**
- Creates a zero-filled numpy array of length `years + 1` (indices 0..years).
- Iterates over DataFrame rows. For each row:
  - Get cost via `pd.to_numeric(row["cost_usd"], errors="coerce")`. Skip if NaN.
  - If `override_costs` dict has a key matching `row["name"]`, use that cost instead.
  - Get lifespan from `row["lifespan_years"]`.
  - If lifespan is the string "indefinite" (case-insensitive), add cost only at year 0.
  - Otherwise, convert lifespan to int and add cost at year 0, then every lifespan years: `for yr in range(0, years + 1, lifespan): annual[yr] += cost`.
- Return `np.cumsum(annual)`.

**4. `compute_chart_data(data: dict, battery_fraction: float = 0.5, years: int = 50) -> dict`**
- This is the main aggregation function called by the chart callback.
- Extracts `mechanical_df = data["mechanical"]`, `electrical_df = data["electrical"]`, `battery_lookup = data["battery_lookup"]`.
- **Battery interpolation:** Calls `interpolate_battery_cost(battery_fraction, battery_lookup)` to get the storage cost.
- **Electrical cost override:** CRITICAL per Research Pitfall 1 — exclude "Battery (1 day of power)" from the electrical base cost. Create `override_costs = {"Battery (1 day of power)": 0}` so the row's cost is zeroed out, then add the interpolated storage cost as a separate entry at year 0 in cost-over-time. Implementation: after computing `compute_cost_over_time(electrical_df, years, override_costs={"Battery (1 day of power)": 0})`, add the interpolated battery cost to `annual[0]` BEFORE cumsum. Actually, simpler approach: compute the cumulative array, then add `interpolated_cost` to every element (since it's a year-0 cost that shifts the entire cumulative line up). So: `elec_cumulative = compute_cost_over_time(electrical_df, years, {"Battery (1 day of power)": 0})` then `elec_cumulative += interpolated_cost`.
- Wait — the battery replacement cycle matters too (lifespan=12 years). Better approach: pass `override_costs={"Battery (1 day of power)": interpolated_cost}` so that compute_cost_over_time uses the interpolated cost for all battery replacements at year 0, 12, 24, 36, 48.
- **Mechanical cumulative:** `compute_cost_over_time(data["mechanical"], years)`.
- **Hybrid placeholder:** `np.zeros(years + 1)` — no hybrid data until Phase 4.
- **Land area:** Sum `pd.to_numeric(df["land_area_m2"], errors="coerce")` for mechanical and electrical. Hybrid = 0.
- **Turbine count:** Mechanical = quantity of "250kW aeromotor turbine " row (use pd.to_numeric on quantity column). Electrical = quantity of "Turbine" row. Hybrid = 0. Use `df[df["name"] == name]["quantity"]` lookup.
- **Energy breakdown:** For each system (mechanical, electrical), group by process stage using `get_equipment_stage()` and sum energy_kw per stage. Return as dict[str, float] (stage_name -> total_kw). Hybrid = empty dict.
- **Electrical total cost:** Sum `pd.to_numeric(electrical_df["cost_usd"], errors="coerce")` excluding "Battery (1 day of power)" row, then add interpolated battery cost. This is the live cost readout value.
- Returns dict with keys: `cost_over_time` (dict of system -> np.ndarray), `land_area` (dict of system -> float), `turbine_count` (dict of system -> int), `energy_breakdown` (dict of system -> dict[str, float]), `electrical_total_cost` (float).
  </action>
  <verify>
Run `python -c "from src.data.processing import compute_cost_over_time, interpolate_battery_cost, compute_chart_data, battery_ratio_label; print('OK')"` — should print OK with no errors.

Run `python -c "
from src.data.loader import load_data
from src.data.processing import compute_chart_data, interpolate_battery_cost, battery_ratio_label
data = load_data()
# Battery interpolation
cost_50 = interpolate_battery_cost(0.5, data['battery_lookup'])
print(f'Battery cost at 50/50: ${cost_50:,.0f}')
# Ratio label
print(battery_ratio_label(0.7))
# Full chart data
cd = compute_chart_data(data, 0.5, 50)
print(f'Mech year 50: ${cd[\"cost_over_time\"][\"mechanical\"][-1]:,.0f}')
print(f'Elec year 50: ${cd[\"cost_over_time\"][\"electrical\"][-1]:,.0f}')
print(f'Mech land: {cd[\"land_area\"][\"mechanical\"]:,.0f} m2')
print(f'Mech turbines: {cd[\"turbine_count\"][\"mechanical\"]}')
print(f'Elec energy stages: {list(cd[\"energy_breakdown\"][\"electrical\"].keys())}')
print(f'Elec total cost: ${cd[\"electrical_total_cost\"]:,.0f}')
"` — Should produce reasonable values. Battery cost at 50/50 should be ~$700,000. Year 50 mechanical should be ~$79M. Hybrid cost_over_time should be all zeros.
  </verify>
  <done>All four functions exist in processing.py and return correct data types. Battery interpolation matches lookup table. Cost-over-time handles replacement cycles and battery override. Hybrid is zero placeholder throughout.</done>
</task>

<task type="auto">
  <name>Task 2: Create charts.py with figure builders and chart section layout</name>
  <files>src/layout/charts.py</files>
  <action>
Create new file `src/layout/charts.py`. This module provides four figure-building functions and the chart section layout factory. NO callbacks in this file — callbacks go in Plan 02.

**Imports:**
```python
import plotly.graph_objects as go
from dash import html, dcc
import dash_bootstrap_components as dbc
from src.config import SYSTEM_COLORS
```

**1. `build_cost_chart(years, mech_cumulative, elec_cumulative, hybrid_cumulative, visibility) -> go.Figure`**
- Per CONTEXT.md: cost-over-time line chart, smooth lines, no data point markers, cumulative cost per year.
- `x = list(range(0, years + 1))`.
- Three `go.Scatter` traces with `mode="lines"`, one per system.
- Colors from `SYSTEM_COLORS` (use system label keys: "Mechanical", "Electrical", "Hybrid").
- `visible=True` if `visibility.get(key, True)` else `"legendonly"` — where key is lowercase system name.
- Hovertemplate per CONTEXT.md: `f"{name}: %{{y:$,.0f}} at Year %{{x}}<extra></extra>"` — dollar sign with comma formatting. Use `hovertemplate` not `text`.
- Layout: `xaxis_title="Year"`, `yaxis_title="Cumulative Cost (USD)"`, `showlegend=False` (external legend), `uirevision="static"`, `transition={"duration": 300, "easing": "cubic-in-out"}`, `margin=dict(l=60, r=20, t=10, b=40)`, `hovermode="x unified"`.
- Line width=2.5, no markers.

**2. `build_land_chart(mech_land, elec_land, hybrid_land, visibility) -> go.Figure`**
- Per CONTEXT.md: grouped bar chart, values on hover only (no labels on bars).
- Three `go.Bar` traces, one per system, `x=["Land Area"]`, `y=[value]`.
- Colors from SYSTEM_COLORS. Visibility same pattern as cost chart.
- `hovertemplate=f"{name}: %{{y:,.0f}} m<sup>2</sup><extra></extra>"`.
- Layout: `barmode="group"`, `yaxis_title="Area (m\u00b2)"`, `showlegend=False`, `uirevision="static"`, `transition={"duration": 300}`, margin.

**3. `build_turbine_chart(mech_count, elec_count, hybrid_count, visibility) -> go.Figure`**
- Same structure as land chart but for turbine count.
- `x=["Wind Turbines"]`, `y=[count]`.
- `hovertemplate=f"{name}: %{{y}} turbines<extra></extra>"`.
- `yaxis_title="Count"`, `dtick=1` (integer axis).

**4. `build_pie_chart(mech_energy, elec_energy, hybrid_energy, visibility) -> go.Figure`**
- Per CONTEXT.md: 3 pie charts side by side (one per system), not a single pie with selector.
- Three `go.Pie` traces using domain positioning. `spacing = 0.05`, `width = (1 - 2 * spacing) / 3`.
- For each system `(label, energy_dict, index)`:
  - `x_start = index * (width + spacing)`, `x_end = x_start + width`.
  - If energy_dict is empty (Hybrid in Phase 3): use `labels=["No data"]`, `values=[1]`, `marker=dict(colors=["#e0e0e0"])` — a single grey "No data" slice.
  - `textinfo="none"` (no labels on slices per CONTEXT.md).
  - `hovertemplate="%{label}: %{percent}<extra></extra>"`.
  - `showlegend=False` (shared legend is external).
  - Apply visibility from the visibility dict.
  - `domain=dict(x=[x_start, x_end], y=[0.15, 1.0])`.
- Add annotations below each pie as system name subtitle: `dict(text=label, x=midpoint, y=0.05, showarrow=False, font=dict(size=12))`.
- Layout: `uirevision="static"`, `transition={"duration": 300}`, `margin=dict(l=10, r=10, t=10, b=10)`.

**5. `make_chart_section() -> html.Div`**
- Returns the FULL chart section layout (no callbacks — just the component tree).
- Structure per CONTEXT.md locked decisions:
  - Section heading: `html.H4("System Comparison", className="mt-4 mb-3")`
  - **Control panel** in a `dbc.Card` with light background:
    - `dbc.Row` with two `dbc.Col(width=6)`:
      - Left col: Time horizon slider
        - Label: `html.Strong("Time Horizon")` + `html.Small(" — Adjust the projection period", className="text-muted ms-1")`
        - `dcc.Slider(id="slider-time-horizon", min=1, max=50, step=1, value=50, marks={1: "1yr", 25: "25yr", 50: "50yr"}, tooltip={"always_visible": True, "placement": "bottom"}, updatemode="drag")`
        - Live label: `html.Span(id="label-years", children="50 years", className="fw-bold ms-2")`
      - Right col: Battery/tank slider
        - Label: `html.Strong("Battery / Tank Tradeoff")` + `html.Small(" — Adjust electrical system storage mix", className="text-muted ms-1")`
        - `dcc.Slider(id="slider-battery", min=0, max=1, step=0.001, value=0.5, marks={}, tooltip={"always_visible": False}, updatemode="drag")`
        - Live ratio label: `html.Span(id="label-battery-ratio", children="50% Battery / 50% Tank", className="fw-bold ms-2")`
        - Live electrical cost: `html.Span(id="label-elec-cost", children="", className="text-muted ms-2")`
    - Card styling: `className="shadow-sm mb-3"`, `body=True`, `style={"backgroundColor": "#f8f9fa"}`
  - **Shared legend row** — clickable badges per system:
    - `html.Div` with `html.Strong("Systems: ", className="me-2")` followed by three `dbc.Badge` components:
      - `id="legend-btn-mechanical"`, `id="legend-btn-electrical"`, `id="legend-btn-hybrid"`
      - Each badge: text=system label, `style={"cursor": "pointer", "backgroundColor": SYSTEM_COLORS[label], "fontSize": "0.9rem"}`, `className="me-2 p-2"`, `pill=True`
    - `className="mb-3 d-flex align-items-center"`
  - **dcc.Store** for legend visibility: `dcc.Store(id="store-legend-visibility", data={"mechanical": True, "electrical": True, "hybrid": True})`
  - **2x2 chart grid** — two `dbc.Row` components, each with two `dbc.Col(lg=6, xs=12)`:
    - Helper function `_chart_card(title, description, graph_id)` returning a `dbc.Col` wrapping a `dbc.Card` with `dbc.CardBody` containing `html.Strong(title)`, `html.P(description, className="text-muted small mb-1")`, `dcc.Graph(id=graph_id, config={"displayModeBar": False})`.
    - Card style: `className="shadow-sm h-100"`, matching existing scorecard card aesthetic.
    - Row 1: chart_card("Cost Over Time", "Cumulative capital cost per year", "chart-cost") + chart_card("Land Area", "Total footprint per system (m\u00b2)", "chart-land")
    - Row 2: chart_card("Wind Turbine Count", "Number of turbines per system", "chart-turbine") + chart_card("Energy Breakdown", "Energy use by process stage (kW)", "chart-pie")
    - Each row: `className="mb-3"`
  - Responsive: `lg=6` for 2-column on large screens, `xs=12` for single column on narrow per CONTEXT.md.
  </action>
  <verify>
Run `python -c "from src.layout.charts import build_cost_chart, build_land_chart, build_turbine_chart, build_pie_chart, make_chart_section; print('OK')"` — should print OK.

Run `python -c "
import numpy as np
from src.layout.charts import build_cost_chart, build_land_chart, build_turbine_chart, build_pie_chart, make_chart_section
vis = {'mechanical': True, 'electrical': True, 'hybrid': True}
# Test cost chart
fig = build_cost_chart(50, np.arange(51)*1000, np.arange(51)*1200, np.zeros(51), vis)
print(f'Cost chart traces: {len(fig.data)}')
# Test land chart
fig = build_land_chart(100, 200, 0, vis)
print(f'Land chart traces: {len(fig.data)}')
# Test turbine chart
fig = build_turbine_chart(4, 1, 0, vis)
print(f'Turbine chart traces: {len(fig.data)}')
# Test pie chart
fig = build_pie_chart({'Extraction': 50, 'Desal': 30}, {'Extraction': 40, 'Desal': 60}, {}, vis)
print(f'Pie chart traces: {len(fig.data)}')
# Test layout
section = make_chart_section()
print(f'Section type: {type(section).__name__}')
"` — Should show 3 traces for each chart and Div for section.
  </verify>
  <done>charts.py exists with all four figure builders returning valid Plotly Figures. make_chart_section returns a complete Dash layout with control panel (both sliders with labels), shared legend badges, dcc.Store for legend visibility, and 2x2 chart grid in responsive card containers. No callbacks in this file.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.data.processing import compute_chart_data; from src.layout.charts import make_chart_section; print('All imports OK')"` passes
2. compute_chart_data returns correct structure with cost_over_time, land_area, turbine_count, energy_breakdown, electrical_total_cost keys
3. All four figure builders accept visibility dict and return go.Figure objects
4. make_chart_section returns a Div containing slider IDs, graph IDs, store ID, and legend badge IDs
5. No callbacks defined in either file (callbacks are Plan 02)
</verification>

<success_criteria>
- processing.py has 4 new functions: interpolate_battery_cost, battery_ratio_label, compute_cost_over_time, compute_chart_data
- charts.py exists with 5 functions: build_cost_chart, build_land_chart, build_turbine_chart, build_pie_chart, make_chart_section
- Battery interpolation uses numpy.interp against the 11-row lookup table
- Cost-over-time handles replacement cycles via lifespan_years and battery cost override
- Hybrid data is placeholder zeros/empty throughout
- All chart figures have uirevision="static" and transition animation
- Chart section has responsive 2x2 grid with lg=6/xs=12 columns
</success_criteria>

<output>
After completion, create `.planning/phases/03-comparison-charts-and-electrical-slider/03-01-SUMMARY.md`
</output>
