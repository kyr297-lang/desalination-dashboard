---
phase: 04-hybrid-builder
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config.py
  - src/data/processing.py
  - src/layout/hybrid_builder.py
autonomous: true
requirements: [HYB-01, HYB-02]

must_haves:
  truths:
    - "Five labeled dropdowns exist for Water Extraction, Pre-Treatment, Desalination, Post-Treatment, Brine Disposal"
    - "Each dropdown shows valid equipment names from the data pool"
    - "Desalination dropdown has options (not empty)"
    - "Selecting/clearing dropdowns updates the slot store correctly"
    - "Clear All button resets all dropdowns to None"
    - "Slot counter shows correct X/5 count"
  artifacts:
    - path: "src/config.py"
      provides: "Extended PROCESS_STAGES with Desalination items"
      contains: "Desalination"
    - path: "src/data/processing.py"
      provides: "compute_hybrid_df and generate_comparison_text functions"
      exports: ["compute_hybrid_df", "generate_comparison_text"]
    - path: "src/layout/hybrid_builder.py"
      provides: "Pipeline builder layout, slot store, and all builder callbacks"
      exports: ["make_hybrid_builder", "SLOT_STAGES"]
  key_links:
    - from: "src/layout/hybrid_builder.py"
      to: "src/config.py"
      via: "PROCESS_STAGES import for dropdown options"
      pattern: "PROCESS_STAGES"
    - from: "src/layout/hybrid_builder.py"
      to: "dcc.Store(store-hybrid-slots)"
      via: "5 dropdown Inputs writing to slot store"
      pattern: "store-hybrid-slots"
---

<objective>
Create the hybrid builder data helpers and pipeline UI component with all 5 equipment slot dropdowns, the slot store, slot counter, Clear All button, and associated callbacks.

Purpose: This is the foundation of the hybrid builder feature — the UI for students to assemble a custom hybrid system and the processing functions that compute hybrid metrics from slot selections.
Output: hybrid_builder.py (self-contained module), extended config.py, and processing.py hybrid helpers
</objective>

<execution_context>
@C:/Users/kevin/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-hybrid-builder/04-CONTEXT.md
@.planning/phases/04-hybrid-builder/04-RESEARCH.md
@src/config.py
@src/data/processing.py
@src/layout/charts.py
@src/layout/scorecard.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend config.py and add hybrid processing helpers</name>
  <files>src/config.py, src/data/processing.py</files>
  <action>
**config.py changes:**
1. In PROCESS_STAGES["miscellaneous"]["Desalination"], add the 4 items from mechanical/electrical sheets: "2 RO membranes in parallel", "RO membranes in parallel", "Gear and Booster Pump", "Booster Pump". Currently this list is empty, which would make the Desalination dropdown have no options.
2. Remove "Multi-Media Filtration" from PROCESS_STAGES["miscellaneous"]["Pre-Treatment"] if present — it exists in the electrical sheet, not miscellaneous, so it would show no matches in the dropdown.

**processing.py changes:**
1. Add `compute_hybrid_df(slots: dict, data: dict) -> pd.DataFrame | None`:
   - Takes the slot store dict (stage -> equipment_name or None) and the full data dict
   - If any slot value is None, return None (gate not met)
   - For each slot, search data["miscellaneous"], then data["mechanical"], then data["electrical"] for a row where name matches
   - Return a DataFrame with the 5 matching rows, or None if any lookup fails
   - Use the same column names as existing DataFrames (name, quantity, cost_usd, energy_kw, land_area_m2, lifespan_years)

2. Add `generate_comparison_text(hybrid_metrics: dict, mech_metrics: dict, elec_metrics: dict) -> str`:
   - For each of 3 metrics (cost, land_area, efficiency), compute percentage difference between hybrid and each preset
   - Return neutral/factual sentences like "Hybrid has 25% less cost than Mechanical."
   - Guard against division by zero and None values
   - Use the same metric keys as compute_scorecard_metrics returns

3. Extend `compute_scorecard_metrics(mechanical_df, electrical_df, hybrid_df=None)` to accept an optional third DataFrame parameter. When hybrid_df is provided and not None, compute hybrid metrics using the same _aggregate pattern and include "hybrid" key in the returned dict. The existing rag_color function should already handle 3-system ranking.

4. Extend `compute_chart_data(data, battery_fraction, years, hybrid_df=None)` to accept an optional hybrid_df parameter. Replace the TODO Phase 4 placeholder zeros with real computed values when hybrid_df is provided:
   - hybrid_cumulative from compute_cost_over_time(hybrid_df, years)
   - hybrid_land from pd.to_numeric sum of land_area_m2
   - hybrid_energy from _energy_by_stage (use "miscellaneous" as system_key, or build from the hybrid_df directly)
   - hybrid_turbines stays 0 (miscellaneous items don't include turbines)
  </action>
  <verify>
Run `python -c "from src.data.processing import compute_hybrid_df, generate_comparison_text; from src.config import PROCESS_STAGES; print(len(PROCESS_STAGES['miscellaneous']['Desalination']), 'desal items'); print('OK')"` — should print "4 desal items" and "OK" with no import errors.
  </verify>
  <done>
config.py has 4 Desalination items in PROCESS_STAGES["miscellaneous"]. processing.py exports compute_hybrid_df, generate_comparison_text. compute_scorecard_metrics and compute_chart_data accept optional hybrid_df parameter. All functions importable without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create hybrid_builder.py with pipeline layout and callbacks</name>
  <files>src/layout/hybrid_builder.py</files>
  <action>
Create `src/layout/hybrid_builder.py` as a self-contained module following the established project pattern (module-level _data, set_data()).

**Layout — make_hybrid_builder(data: dict) -> html.Div:**
1. Define SLOT_STAGES = ["Water Extraction", "Pre-Treatment", "Desalination", "Post-Treatment", "Brine Disposal"]
2. Create dcc.Store(id="store-hybrid-slots", data={stage: None for stage in SLOT_STAGES})
3. Build a horizontal pipeline with arrows between stages:
   - Each stage: html.Div containing a Label (stage name, small/bold/text-muted) and a dcc.Dropdown
   - Dropdown IDs: "slot-dd-water-extraction", "slot-dd-pre-treatment", "slot-dd-desalination", "slot-dd-post-treatment", "slot-dd-brine-disposal"
   - Dropdown options built from _build_dropdown_options(stage, data) — searches PROCESS_STAGES["miscellaneous"][stage] items in miscellaneous/mechanical/electrical DataFrames
   - Options show equipment names only (label=name, value=name), clearable=True, placeholder="Select..."
   - Between each stage, add an arrow span: html.Span("→", className for vertical centering and muted color, fs-4 for size)
4. Pipeline row uses d-flex flex-wrap with gap for responsive wrapping (not horizontal scroll)
5. Above pipeline: slot counter (html.Span id="slot-counter") and Clear All button (dbc.Button id="btn-clear-all", size="sm", color="secondary", outline=True)
6. Title: html.H5("Hybrid System Builder", className="mb-3")
7. Style: minWidth 160px on each dropdown for readability

**Callbacks (all in this module):**

1. update_slot_store — 5 dropdown value Inputs -> Output("store-hybrid-slots", "data")
   - Simply constructs the dict from the 5 values

2. clear_all_slots — Input("btn-clear-all", "n_clicks") -> Output all 5 dropdown values to None
   - prevent_initial_call=True
   - Does NOT write to store directly — cascade through update_slot_store

3. update_slot_counter — Input("store-hybrid-slots", "data") -> Output("slot-counter", "children")
   - Shows "X/5 slots filled"

**Helper — _build_dropdown_options(stage, data):**
- Get item names from PROCESS_STAGES["miscellaneous"][stage]
- For each name, verify it exists in at least one of the DataFrames (miscellaneous, mechanical, electrical)
- Return list of {"label": name, "value": name} dicts
- Skip names that don't match any DataFrame row

**Anti-patterns to avoid:**
- Do NOT build options inside a callback — build at layout time (data is static)
- Do NOT write store-hybrid-slots from multiple callbacks — only update_slot_store writes it
- Do NOT call make_chart_section() — the chart section is shared with other tabs
  </action>
  <verify>
Run `python -c "from src.layout.hybrid_builder import make_hybrid_builder, SLOT_STAGES; print(len(SLOT_STAGES), 'stages'); print('OK')"` — should print "5 stages" and "OK". Then run `python -c "from src.layout.hybrid_builder import make_hybrid_builder; from src.data.loader import load_data; d = load_data(); b = make_hybrid_builder(d); print(type(b).__name__); print('OK')"` — should print "Div" and "OK".
  </verify>
  <done>
hybrid_builder.py exports make_hybrid_builder() and SLOT_STAGES. The builder renders 5 labeled dropdowns in a horizontal pipeline with arrows, a slot counter, and a Clear All button. Three callbacks handle slot store updates, clear all, and counter display. All callbacks self-contained in the module.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.config import PROCESS_STAGES; assert len(PROCESS_STAGES['miscellaneous']['Desalination']) == 4"` passes
2. `python -c "from src.data.processing import compute_hybrid_df, generate_comparison_text"` imports cleanly
3. `python -c "from src.layout.hybrid_builder import make_hybrid_builder, SLOT_STAGES; assert len(SLOT_STAGES) == 5"` passes
4. `python app.py` starts without errors (no duplicate IDs, no import failures)
</verification>

<success_criteria>
- hybrid_builder.py is a complete, self-contained module with layout and callbacks
- Processing helpers (compute_hybrid_df, generate_comparison_text) exist and are importable
- Config has Desalination dropdown options (4 items)
- App starts without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-hybrid-builder/04-01-SUMMARY.md`
</output>
