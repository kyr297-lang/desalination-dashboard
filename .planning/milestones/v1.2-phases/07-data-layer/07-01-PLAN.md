---
phase: 07-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/data/loader.py
autonomous: true
requirements:
  - DATA-01
  - DATA-02
  - DATA-03

must_haves:
  truths:
    - "App reads equipment data from the sheet named 'Part 1' without raising ValueError"
    - "load_data() returns a 'tds_lookup' DataFrame with columns ['tds_ppm', 'ro_energy_kw'] and 20 rows"
    - "load_data() returns a 'depth_lookup' DataFrame with columns ['depth_m', 'pump_energy_kw'] and 20 rows"
  artifacts:
    - path: "src/data/loader.py"
      provides: "Updated loader that reads 'Part 1' and parses both Part 2 lookup tables"
      exports: ["load_data"]
      contains: "Part 1"
  key_links:
    - from: "src/data/loader.py"
      to: "data.xlsx sheet 'Part 1'"
      via: "wb['Part 1']"
      pattern: "wb\\[.Part 1.\\]"
    - from: "src/data/loader.py"
      to: "data.xlsx sheet 'Part 2'"
      via: "wb['Part 2']"
      pattern: "wb\\[.Part 2.\\]"
---

<objective>
Update loader.py so the app reads equipment data from the renamed "Part 1" sheet and ingests both Part 2 lookup tables (TDS vs RO-energy; Depth vs pump-energy) into named DataFrames.

Purpose: data.xlsx was renamed from "Sheet1" to "Part 1" and now has a "Part 2" sheet with two lookup tables needed by the Phase 8 sliders. The app currently crashes at startup because it looks for "Sheet1".

Output: Updated src/data/loader.py with "Part 1" support and two new parser functions. load_data() returns a dict with two additional keys: 'tds_lookup' and 'depth_lookup'.
</objective>

<execution_context>
@C:/Users/kevin/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/data/loader.py

<interfaces>
<!-- Current load_data() return shape (to be extended, not replaced): -->

From src/data/loader.py:
```python
def load_data() -> dict[str, pd.DataFrame]:
    """
    Returns dict with keys:
        "electrical"    – pd.DataFrame (equipment rows)
        "mechanical"    – pd.DataFrame (equipment rows)
        "miscellaneous" – pd.DataFrame (equipment rows)
        "battery_lookup"– pd.DataFrame (battery fraction vs tank fraction)
    """
```

<!-- Part 2 sheet layout (confirmed by inspection): -->
<!-- data.xlsx "Part 2" sheet structure:
     Row 1 (headers): col A="TDS", col B="kW required (RO Desalination)", col D="Depth", col E="kW required (pump energy)"
     Rows 2-21 (data): TDS values 0,100,200,...,1900 in col A; RO-energy kW in col B
                       Depth values 0,100,200,...,1900 in col D; pump-energy kW in col E
     20 data rows total for each table.
-->

<!-- Current sheet reference that must be changed (line 175-180): -->
```python
    if "Sheet1" not in wb.sheetnames:
        raise ValueError(
            f"Expected sheet 'Sheet1' not found. "
            f"Available sheets: {wb.sheetnames}"
        )
    ws = wb["Sheet1"]
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Part 1 sheet reference</name>
  <files>src/data/loader.py</files>
  <action>
In src/data/loader.py, update the module-level docstring and the load_data() function body to reference "Part 1" instead of "Sheet1":

1. Update the module docstring (line 8): change `("Sheet1")` to `("Part 1")`.

2. In load_data(), update the sheet existence check (currently around lines 175-180):
   - Change the string "Sheet1" to "Part 1" in both the `if` condition and the error message.
   - Change `ws = wb["Sheet1"]` to `ws = wb["Part 1"]`.

3. Update the ValueError message to say `Expected sheet 'Part 1'` (not Sheet1).

Do NOT change any other logic. The equipment parsing functions (_parse_section, _parse_battery_lookup) and SECTION_HEADERS/EQUIPMENT_COLUMNS/BATTERY_COLUMNS constants are unchanged.
  </action>
  <verify>
    <automated>cd "C:/Users/kevin/Downloads/Desalination Project Vibe Code" && python -c "
import openpyxl
wb = openpyxl.load_workbook('data.xlsx', data_only=True)
print('Sheets:', wb.sheetnames)
assert 'Part 1' in wb.sheetnames, 'Part 1 sheet missing from data.xlsx'
from src.data.loader import load_data
data = load_data()
assert 'electrical' in data, 'electrical key missing'
assert 'mechanical' in data, 'mechanical key missing'
assert 'miscellaneous' in data, 'miscellaneous key missing'
print('Task 1 PASS: Part 1 sheet loads correctly')
print('Electrical rows:', len(data['electrical']))
print('Mechanical rows:', len(data['mechanical']))
"
</automated>
  </verify>
  <done>load_data() opens "Part 1" sheet without error; electrical, mechanical, and miscellaneous DataFrames are non-empty; no reference to "Sheet1" remains in loader.py.</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Add Part 2 lookup table parsers</name>
  <files>src/data/loader.py</files>
  <behavior>
    - _parse_part2_lookups(wb) reads the "Part 2" sheet from the already-opened workbook.
    - Returns a tuple: (tds_df, depth_df).
    - tds_df has columns ["tds_ppm", "ro_energy_kw"], 20 rows, TDS values 0-1900 in 100 PPM steps.
    - depth_df has columns ["depth_m", "pump_energy_kw"], 20 rows, depth values 0-1900 in 100 m steps.
    - Both DataFrames have numeric dtypes (float or int); no None values in data rows.
    - load_data() includes "tds_lookup" and "depth_lookup" keys in its return dict.
    - If "Part 2" sheet is missing, raises ValueError: "Expected sheet 'Part 2' not found."
  </behavior>
  <action>
Add the following to src/data/loader.py:

1. Add two column-name constants near the top (after BATTERY_COLUMNS):
   ```python
   TDS_LOOKUP_COLUMNS = ["tds_ppm", "ro_energy_kw"]
   DEPTH_LOOKUP_COLUMNS = ["depth_m", "pump_energy_kw"]
   ```

2. Add private helper function `_parse_part2_lookups(wb)` before the `load_data` function:
   ```python
   def _parse_part2_lookups(wb) -> tuple[pd.DataFrame, pd.DataFrame]:
       """
       Parse both lookup tables from the 'Part 2' sheet.

       Layout (confirmed from data.xlsx):
         Row 1: headers — col A="TDS", col B="kW required (RO Desalination)",
                          col D="Depth", col E="kW required (pump energy)"
         Rows 2-21: 20 data rows for each table (values 0-1900 in 100-unit steps)

       Returns
       -------
       tuple[pd.DataFrame, pd.DataFrame]
           (tds_df, depth_df)
           tds_df columns:   ["tds_ppm", "ro_energy_kw"]
           depth_df columns: ["depth_m", "pump_energy_kw"]
       """
       if "Part 2" not in wb.sheetnames:
           raise ValueError(
               f"Expected sheet 'Part 2' not found. "
               f"Available sheets: {wb.sheetnames}"
           )
       ws2 = wb["Part 2"]

       tds_rows = []
       depth_rows = []
       for r in range(2, 22):   # rows 2-21 inclusive (20 data rows)
           tds_rows.append({
               "tds_ppm":      ws2.cell(r, 1).value,   # col A
               "ro_energy_kw": ws2.cell(r, 2).value,   # col B
           })
           depth_rows.append({
               "depth_m":        ws2.cell(r, 4).value, # col D
               "pump_energy_kw": ws2.cell(r, 5).value, # col E
           })

       tds_df   = pd.DataFrame(tds_rows,   columns=TDS_LOOKUP_COLUMNS)
       depth_df = pd.DataFrame(depth_rows, columns=DEPTH_LOOKUP_COLUMNS)

       print(f"  [loader] TDS lookup:   {len(tds_df)} rows parsed")
       print(f"  [loader] Depth lookup: {len(depth_df)} rows parsed")
       return tds_df, depth_df
   ```

3. In load_data(), after opening the workbook (after step 2, before the "Part 1" sheet check), add a call to parse Part 2:
   ```python
   # ── 2b. Parse Part 2 lookup tables ──────────────────────────────────────
   tds_df, depth_df = _parse_part2_lookups(wb)
   ```

4. In load_data(), add the two new keys to the return dict:
   ```python
   return {
       "electrical":    pd.DataFrame(electrical_rows,    columns=EQUIPMENT_COLUMNS),
       "mechanical":    pd.DataFrame(mechanical_rows,    columns=EQUIPMENT_COLUMNS),
       "miscellaneous": pd.DataFrame(miscellaneous_rows, columns=EQUIPMENT_COLUMNS),
       "battery_lookup": battery_df,
       "tds_lookup":    tds_df,
       "depth_lookup":  depth_df,
   }
   ```

5. Update the load_data() docstring to document the two new keys:
   ```
   "tds_lookup"    – pd.DataFrame with columns ["tds_ppm", "ro_energy_kw"], 20 rows (TDS 0–1900 PPM)
   "depth_lookup"  – pd.DataFrame with columns ["depth_m", "pump_energy_kw"], 20 rows (Depth 0–1900 m)
   ```
  </action>
  <verify>
    <automated>cd "C:/Users/kevin/Downloads/Desalination Project Vibe Code" && python -c "
from src.data.loader import load_data
data = load_data()

# DATA-02: TDS lookup
assert 'tds_lookup' in data, 'tds_lookup key missing from load_data()'
tds = data['tds_lookup']
assert list(tds.columns) == ['tds_ppm', 'ro_energy_kw'], f'Wrong TDS columns: {list(tds.columns)}'
assert len(tds) == 20, f'Expected 20 TDS rows, got {len(tds)}'
assert tds['tds_ppm'].iloc[0] == 0, f'First TDS value should be 0, got {tds[\"tds_ppm\"].iloc[0]}'
assert tds['tds_ppm'].iloc[-1] == 1900, f'Last TDS value should be 1900, got {tds[\"tds_ppm\"].iloc[-1]}'
assert tds['ro_energy_kw'].notna().all(), 'tds_lookup has None values'
print('DATA-02 PASS: tds_lookup OK — rows:', len(tds), '| first kW:', tds['ro_energy_kw'].iloc[0])

# DATA-03: Depth lookup
assert 'depth_lookup' in data, 'depth_lookup key missing from load_data()'
depth = data['depth_lookup']
assert list(depth.columns) == ['depth_m', 'pump_energy_kw'], f'Wrong depth columns: {list(depth.columns)}'
assert len(depth) == 20, f'Expected 20 depth rows, got {len(depth)}'
assert depth['depth_m'].iloc[0] == 0, f'First depth value should be 0, got {depth[\"depth_m\"].iloc[0]}'
assert depth['depth_m'].iloc[-1] == 1900, f'Last depth value should be 1900, got {depth[\"depth_m\"].iloc[-1]}'
assert depth['pump_energy_kw'].notna().all(), 'depth_lookup has None values'
print('DATA-03 PASS: depth_lookup OK — rows:', len(depth), '| first kW:', depth['pump_energy_kw'].iloc[0])

print('All assertions passed.')
"
</automated>
  </verify>
  <done>load_data() returns dict with "tds_lookup" (20 rows, columns tds_ppm/ro_energy_kw) and "depth_lookup" (20 rows, columns depth_m/pump_energy_kw). Both DataFrames have no None values and correct TDS/depth ranges 0-1900 in 100-unit steps.</done>
</task>

</tasks>

<verification>
Run the full app startup to confirm no errors:

```bash
cd "C:/Users/kevin/Downloads/Desalination Project Vibe Code"
python -c "
from src.data.loader import load_data
data = load_data()
keys = list(data.keys())
print('Keys returned:', keys)
assert 'electrical' in data
assert 'mechanical' in data
assert 'miscellaneous' in data
assert 'battery_lookup' in data
assert 'tds_lookup' in data
assert 'depth_lookup' in data
print('SUCCESS: all 6 keys present')
print('tds_lookup shape:', data['tds_lookup'].shape)
print('depth_lookup shape:', data['depth_lookup'].shape)
"
```

Expected output:
```
  [loader] Found section 'Electrical Components' at row ...
  [loader] Found section 'Mechanical Components' at row ...
  [loader] Found section 'Miscalleneous' at row ...
  [loader] TDS lookup:   20 rows parsed
  [loader] Depth lookup: 20 rows parsed
  [loader] Electrical:    N equipment rows parsed
  [loader] Mechanical:    N equipment rows parsed
  [loader] Miscellaneous: N equipment rows parsed
  [loader] Battery lookup: N rows parsed
Keys returned: ['electrical', 'mechanical', 'miscellaneous', 'battery_lookup', 'tds_lookup', 'depth_lookup']
SUCCESS: all 6 keys present
tds_lookup shape: (20, 2)
depth_lookup shape: (20, 2)
```
</verification>

<success_criteria>
1. src/data/loader.py opens the "Part 1" sheet (not "Sheet1") without error — DATA-01
2. load_data() returns "tds_lookup" DataFrame: 20 rows, columns ["tds_ppm", "ro_energy_kw"], TDS range 0-1900 PPM — DATA-02
3. load_data() returns "depth_lookup" DataFrame: 20 rows, columns ["depth_m", "pump_energy_kw"], depth range 0-1900 m — DATA-03
4. All existing keys (electrical, mechanical, miscellaneous, battery_lookup) still present and non-empty
5. No reference to "Sheet1" remains anywhere in loader.py
</success_criteria>

<output>
After completion, create `.planning/phases/07-data-layer/07-01-SUMMARY.md` with:
- What was changed in loader.py (sheet name fix + new functions)
- The new load_data() return shape (all 6 keys with column names)
- The Part 2 sheet layout that was confirmed (rows 2-21, col A-B for TDS, col D-E for depth)
- Any deviations from this plan
</output>
