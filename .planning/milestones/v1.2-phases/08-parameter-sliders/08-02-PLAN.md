---
phase: 08-parameter-sliders
plan: 02
type: execute
wave: 2
depends_on:
  - 08-01
files_modified:
  - src/data/processing.py
  - src/layout/charts.py
autonomous: false
requirements:
  - SLDR-01
  - SLDR-02
  - SLDR-03

must_haves:
  truths:
    - "A TDS slider (0–1900 PPM, default 950, updatemode='drag') is visible in the chart-controls card on all tabs"
    - "A depth slider (0–1900 m, default 950, updatemode='drag') is visible in the chart-controls card on all tabs"
    - "Moving either slider updates all 4 charts live without a page reload"
    - "The power breakdown (pie) chart values reflect interpolated kW from the Part 2 lookup tables at the selected slider positions"
    - "Each slider shows the current numeric value via an always-visible tooltip and a dynamic html.Span label below (e.g. '950 PPM', '950 m')"
  artifacts:
    - path: "src/data/processing.py"
      provides: "compute_chart_data() accepts tds_ppm and depth_m kwargs; uses interpolate_energy() to adjust energy_breakdown values"
      exports: ["compute_chart_data", "interpolate_energy"]
    - path: "src/layout/charts.py"
      provides: "TDS and depth dcc.Slider components in make_chart_section(); update_charts callback wired to new slider inputs"
  key_links:
    - from: "src/layout/charts.py"
      to: "src/data/processing.py"
      via: "compute_chart_data(data, battery_fraction, years, tds_ppm=tds_ppm, depth_m=depth_m)"
      pattern: "compute_chart_data\\(.*tds_ppm"
    - from: "src/layout/charts.py"
      to: "slider-tds (dcc.Slider)"
      via: "Input('slider-tds', 'value') in update_charts callback"
      pattern: "slider-tds"
    - from: "src/layout/charts.py"
      to: "slider-depth (dcc.Slider)"
      via: "Input('slider-depth', 'value') in update_charts callback"
      pattern: "slider-depth"
---

<objective>
Wire the TDS and depth sliders end-to-end: add UI components to the chart-controls
card, extend the update_charts callback to accept them as new Inputs, and extend
compute_chart_data() to use interpolated energy offsets when computing the energy
breakdown chart.

Purpose: Students can drag either slider and see the power breakdown chart (and
turbine count chart) update live, reflecting how source water salinity and depth
change energy demand.

Output: Two new sliders in the chart-controls card; live chart updates driven by
those sliders via the existing update_charts callback.
</objective>

<execution_context>
@C:/Users/kevin/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-parameter-sliders/08-01-SUMMARY.md
@src/layout/charts.py
@src/data/processing.py
@src/data/loader.py

<interfaces>
<!-- Key contracts the executor needs. Extracted from codebase. -->

From src/data/loader.py — lookup table keys in the data dict:
```python
# data["tds_lookup"]   — pd.DataFrame, columns=["tds_ppm", "ro_energy_kw"],   20 rows, 0-1900 in 100-unit steps
# data["depth_lookup"] — pd.DataFrame, columns=["depth_m", "pump_energy_kw"], 20 rows, 0-1900 in 100-unit steps
# Both are already present in _data (set via set_data() in charts.py)
```

From src/data/processing.py — new function from 08-01:
```python
def interpolate_energy(value: float, lookup_df: pd.DataFrame, col_x: str, col_y: str) -> float:
    """Returns linearly interpolated kW from a 20-row Part 2 lookup table."""
```

From src/data/processing.py — existing compute_chart_data() signature to extend:
```python
def compute_chart_data(
    data: dict,
    battery_fraction: float = 0.5,
    years: int = 50,
    hybrid_df: pd.DataFrame | None = None,
) -> dict:
    # Returns dict with keys: cost_over_time, land_area, turbine_count,
    #                          energy_breakdown, electrical_total_cost
    # energy_breakdown = {"mechanical": {stage: kw}, "electrical": {stage: kw}, "hybrid": {}}
```

From src/layout/charts.py — existing slider pattern to replicate:
```python
# Time Horizon slider (left column) — replicate this exact pattern for TDS:
html.Div([
    html.Strong("Time Horizon"),
    html.Small(" \u2014 Adjust the projection period", className="text-muted ms-1"),
], className="mb-1"),
dcc.Slider(
    id="slider-time-horizon",
    min=1, max=50, step=1, value=50,
    marks={1: "1yr", 25: "25yr", 50: "50yr"},
    tooltip={"always_visible": True, "placement": "bottom"},
    updatemode="mouseup",  # <-- use "drag" for new sliders (per user decision)
),
html.Span(id="label-years", children="50 years", className="fw-bold ms-2"),
```

From src/layout/charts.py — existing update_charts callback signature to extend:
```python
@callback(
    Output("chart-cost", "figure"),
    Output("chart-land", "figure"),
    Output("chart-turbine", "figure"),
    Output("chart-pie", "figure"),
    Output("label-years", "children"),
    Output("label-battery-ratio", "children"),
    Output("label-elec-cost", "children"),
    Input("slider-time-horizon", "value"),
    Input("slider-battery", "value"),
    Input("store-legend-visibility", "data"),
    Input("store-hybrid-slots", "data"),
)
def update_charts(years, battery_fraction, visibility, slots):
    ...
    cd = compute_chart_data(_data, battery_fraction, years, hybrid_df=hybrid_df)
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Extend compute_chart_data() to accept and apply TDS and depth energy offsets</name>
  <files>src/data/processing.py, tests/test_compute_chart_data_sliders.py</files>
  <behavior>
    - Test A: compute_chart_data(data, tds_ppm=0, depth_m=0) returns energy_breakdown values equal to the baseline (no TDS/depth offset at zero)
    - Test B: compute_chart_data(data, tds_ppm=950, depth_m=950) returns mechanical energy_breakdown that includes the interpolated ro_energy_kw and pump_energy_kw values added to the base "Desalination" and "Water Extraction" stage totals (or a new stage key if neither stage exists)
    - Test C: tds_ppm and depth_m default to 950 when omitted (midpoint defaults per user decision)
    - Test D: The function signature change is backward-compatible — existing callers without tds_ppm/depth_m still work

    Use a synthetic data dict in tests (small DataFrames matching the equipment column schema + minimal tds_lookup/depth_lookup with known values). Do NOT read data.xlsx in tests.
  </behavior>
  <action>
    In src/data/processing.py, extend compute_chart_data() signature:

    ```python
    def compute_chart_data(
        data: dict,
        battery_fraction: float = 0.5,
        years: int = 50,
        hybrid_df: pd.DataFrame | None = None,
        tds_ppm: float = 950,
        depth_m: float = 950,
    ) -> dict:
    ```

    After the existing _energy_by_stage() calls that produce mech_energy and elec_energy,
    apply the TDS and depth offsets to BOTH mech_energy and elec_energy:

    1. Interpolate ro_energy_kw from data["tds_lookup"] using:
       `ro_kw = interpolate_energy(tds_ppm, data["tds_lookup"], "tds_ppm", "ro_energy_kw")`

    2. Interpolate pump_energy_kw from data["depth_lookup"] using:
       `pump_kw = interpolate_energy(depth_m, data["depth_lookup"], "depth_m", "pump_energy_kw")`

    3. Add ro_kw to the "Desalination" stage key in mech_energy and elec_energy
       (create the key if it doesn't exist, otherwise add to the existing value):
       `mech_energy["Desalination"] = mech_energy.get("Desalination", 0.0) + ro_kw`
       `elec_energy["Desalination"] = elec_energy.get("Desalination", 0.0) + ro_kw`

    4. Add pump_kw to the "Water Extraction" stage key in mech_energy and elec_energy:
       `mech_energy["Water Extraction"] = mech_energy.get("Water Extraction", 0.0) + pump_kw`
       `elec_energy["Water Extraction"] = elec_energy.get("Water Extraction", 0.0) + pump_kw`

    Rationale for applying to both systems: TDS and depth affect the desalination and
    pumping requirements regardless of drive type. The turbine count chart will
    automatically reflect the higher energy demand once energy_breakdown totals increase —
    do NOT modify the turbine count logic in this task.

    Also add tds_ppm and depth_m to the function's docstring Parameters section and
    update the module docstring Exports entry for compute_chart_data to note the new kwargs.
  </action>
  <verify>
    <automated>cd "C:/Users/kevin/Downloads/Desalination Project Vibe Code" && python -m pytest tests/test_compute_chart_data_sliders.py -v</automated>
  </verify>
  <done>
    All tests pass. compute_chart_data() accepts tds_ppm and depth_m kwargs with default 950.
    Interpolated RO and pump energy values appear in energy_breakdown for both mechanical and electrical systems.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add TDS and depth sliders to make_chart_section() and wire update_charts() callback</name>
  <files>src/layout/charts.py</files>
  <action>
    ## Part A — make_chart_section() layout changes

    In the `make_chart_section()` function, add a SECOND dbc.Row inside the control_panel
    dbc.CardBody, below the existing row that holds the Time Horizon and Battery/Tank sliders.

    The existing CardBody currently contains one dbc.Row. Change it to contain two rows:

    ```python
    dbc.CardBody([
        dbc.Row([  # existing row — Time Horizon + Battery/Tank (UNCHANGED)
            ...
        ]),
        dbc.Row([  # NEW row — TDS + Depth sliders
            # Left column: TDS slider
            dbc.Col(
                [
                    html.Div([
                        html.Strong("Source Water Salinity"),
                        html.Small(
                            " \u2014 Adjust to model RO energy demand",
                            className="text-muted ms-1",
                        ),
                    ], className="mb-1"),
                    dcc.Slider(
                        id="slider-tds",
                        min=0,
                        max=1900,
                        step=1,
                        value=950,
                        marks={0: "0", 950: "950", 1900: "1900"},
                        tooltip={"always_visible": True, "placement": "bottom"},
                        updatemode="drag",
                    ),
                    html.Span(
                        id="label-tds",
                        children="950 PPM",
                        className="fw-bold ms-2",
                    ),
                ],
                width=6,
            ),
            # Right column: Depth slider
            dbc.Col(
                [
                    html.Div([
                        html.Strong("Water Source Depth"),
                        html.Small(
                            " \u2014 Adjust to model pump energy demand",
                            className="text-muted ms-1",
                        ),
                    ], className="mb-1"),
                    dcc.Slider(
                        id="slider-depth",
                        min=0,
                        max=1900,
                        step=1,
                        value=950,
                        marks={0: "0", 950: "950", 1900: "1900"},
                        tooltip={"always_visible": True, "placement": "bottom"},
                        updatemode="drag",
                    ),
                    html.Span(
                        id="label-depth",
                        children="950 m",
                        className="fw-bold ms-2",
                    ),
                ],
                width=6,
            ),
        ], className="mt-3"),
    ])
    ```

    ## Part B — update_charts() callback changes

    Add two new Inputs and two new Outputs to the existing @callback decorator:

    New Outputs (add after "label-elec-cost"):
    - Output("label-tds", "children")
    - Output("label-depth", "children")

    New Inputs (add after "store-hybrid-slots"):
    - Input("slider-tds", "value")
    - Input("slider-depth", "value")

    Update the function signature to add tds_ppm and depth_m parameters:
    ```python
    def update_charts(years, battery_fraction, visibility, slots, tds_ppm, depth_m):
    ```

    Update the compute_chart_data() call to pass the new parameters:
    ```python
    cd = compute_chart_data(_data, battery_fraction, years, hybrid_df=hybrid_df, tds_ppm=tds_ppm, depth_m=depth_m)
    ```

    Compute the new label strings:
    ```python
    label_tds = f"{int(round(tds_ppm))} PPM"
    label_depth = f"{int(round(depth_m))} m"
    ```

    Update the return tuple (add label_tds and label_depth at the end):
    ```python
    return cost_fig, land_fig, turbine_fig, pie_fig, label_years, label_ratio, label_cost, label_tds, label_depth
    ```

    Update the module docstring at the top of charts.py to reflect the new signature:
    `update_charts(years, battery_fraction, visibility, slots, tds_ppm, depth_m) -> tuple`

    ## Guard clause
    The existing guard clause `if _data is None: return empty, empty, empty, empty, "", "", ""`
    must also return two additional empty strings:
    `return empty, empty, empty, empty, "", "", "", "", ""`
  </action>
  <verify>
    <automated>cd "C:/Users/kevin/Downloads/Desalination Project Vibe Code" && python -c "from src.layout.charts import make_chart_section, update_charts; print('imports OK')"</automated>
  </verify>
  <done>
    Charts module imports without error. make_chart_section() creates slider-tds and slider-depth
    components. update_charts callback has 9 outputs and 6 inputs. label-tds and label-depth span
    IDs are defined in layout and referenced in callback outputs.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    TDS and depth sliders added to the chart-controls card. Moving either slider triggers live
    updates to all 4 charts. The power breakdown (pie) chart and turbine count chart reflect
    the interpolated energy demand from the Part 2 lookup tables. Each slider shows an
    always-visible tooltip and a dynamic label below (e.g. "950 PPM", "950 m").
  </what-built>
  <how-to-verify>
    1. Start the app: cd "C:/Users/kevin/Downloads/Desalination Project Vibe Code" && python app.py
    2. Open http://127.0.0.1:8050 in a browser
    3. Navigate to any system tab that shows the System Comparison section
    4. Confirm TWO new sliders appear below the existing Time Horizon and Battery/Tank sliders:
       - "Source Water Salinity" slider (0–1900, default at 950, label shows "950 PPM")
       - "Water Source Depth" slider (0–1900, default at 950, label shows "950 m")
    5. Drag the TDS slider to 0 — confirm the Energy Breakdown chart updates (Desalination stage shrinks)
    6. Drag the TDS slider to 1900 — confirm the Energy Breakdown chart updates (Desalination stage grows)
    7. Drag the Depth slider to 0 — confirm the Energy Breakdown chart updates (Water Extraction stage shrinks)
    8. Drag the Depth slider to 1900 — confirm the Energy Breakdown chart updates (Water Extraction stage grows)
    9. Confirm the numeric label under each slider updates as you drag (e.g. "1900 PPM", "1900 m")
    10. Confirm the existing Time Horizon and Battery/Tank sliders still work correctly
    11. Confirm no error page or traceback in the terminal
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After all auto tasks and the checkpoint:

1. python -m pytest tests/test_interpolate_energy.py tests/test_compute_chart_data_sliders.py -v
   → All tests GREEN

2. python -c "from src.layout.charts import make_chart_section; print('OK')"
   → No import errors

3. App runs and both sliders are interactive, per checkpoint verification steps
</verification>

<success_criteria>
1. Requirement SLDR-01: slider-tds visible with range 0–1900, default 950, label "PPM", updatemode="drag"
2. Requirement SLDR-02: slider-depth visible with range 0–1900, default 950, label "m", updatemode="drag"
3. Requirement SLDR-03: moving either slider updates all 4 charts live without page reload; power breakdown
   reflects interpolated values from tds_lookup and depth_lookup DataFrames at the selected position
4. All tests pass: pytest tests/test_interpolate_energy.py tests/test_compute_chart_data_sliders.py
5. Human checkpoint approved
</success_criteria>

<output>
After completion, create `.planning/phases/08-parameter-sliders/08-02-SUMMARY.md`
</output>
