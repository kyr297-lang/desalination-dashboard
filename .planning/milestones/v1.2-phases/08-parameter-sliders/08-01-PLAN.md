---
phase: 08-parameter-sliders
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/data/processing.py
  - tests/test_interpolate_energy.py
autonomous: true
requirements:
  - SLDR-01
  - SLDR-02

must_haves:
  truths:
    - "interpolate_energy(950, tds_lookup, 'tds_ppm', 'ro_energy_kw') returns the correct midpoint kW value"
    - "interpolate_energy clamps values below 0 to the first row's output"
    - "interpolate_energy clamps values above 1900 to the last row's output"
    - "interpolate_energy produces a linearly interpolated float for values between lookup rows"
  artifacts:
    - path: "tests/test_interpolate_energy.py"
      provides: "Failing tests for energy interpolation logic"
    - path: "src/data/processing.py"
      provides: "interpolate_energy() function available for import"
      exports: ["interpolate_energy"]
  key_links:
    - from: "tests/test_interpolate_energy.py"
      to: "src/data/processing.py"
      via: "from src.data.processing import interpolate_energy"
      pattern: "from src\\.data\\.processing import interpolate_energy"
---

<objective>
TDD implementation of interpolate_energy() — the pure function that maps a slider
value (TDS PPM or depth m) to an energy requirement (kW) via numpy.interp against
a 20-row Part 2 lookup DataFrame.

Purpose: The interpolation function has well-defined I/O contracts (scalar in,
scalar out, 20-row DataFrame) making it an ideal TDD target. Testing it in isolation
before wiring to the callback catches edge cases (clamping, NaN handling) before they
surface as silent errors in chart output.

Output: tests/test_interpolate_energy.py (test suite) + interpolate_energy() added
to src/data/processing.py (tested implementation).
</objective>

<execution_context>
@C:/Users/kevin/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/data/processing.py
@src/data/loader.py

<interfaces>
<!-- Key contracts the executor needs. Extracted from codebase. -->

From src/data/loader.py — TDS lookup DataFrame columns:
```python
TDS_LOOKUP_COLUMNS = ["tds_ppm", "ro_energy_kw"]
DEPTH_LOOKUP_COLUMNS = ["depth_m", "pump_energy_kw"]
# 20 rows each, values 0-1900 in 100-unit steps
# Populated by _parse_part2_lookups() and returned from load_data() as:
#   data["tds_lookup"]   — pd.DataFrame(columns=["tds_ppm", "ro_energy_kw"])
#   data["depth_lookup"] — pd.DataFrame(columns=["depth_m", "pump_energy_kw"])
```

From src/data/processing.py — existing interpolation helper to mirror:
```python
def interpolate_battery_cost(battery_fraction: float, battery_lookup_df: pd.DataFrame) -> float:
    fractions = pd.to_numeric(battery_lookup_df["battery_fraction"], errors="coerce").values
    costs = pd.to_numeric(battery_lookup_df["total_cost"], errors="coerce").values
    return float(np.interp(battery_fraction, fractions, costs))
```

New function signature to implement:
```python
def interpolate_energy(value: float, lookup_df: pd.DataFrame, col_x: str, col_y: str) -> float:
    """Interpolate an energy value (kW) from a Part 2 lookup table.

    Parameters
    ----------
    value : float
        Slider value (e.g. TDS in PPM or depth in m). Clamped to [min, max] of col_x.
    lookup_df : pd.DataFrame
        20-row lookup DataFrame from load_data() (tds_lookup or depth_lookup).
    col_x : str
        Name of the independent variable column (e.g. "tds_ppm" or "depth_m").
    col_y : str
        Name of the energy output column (e.g. "ro_energy_kw" or "pump_energy_kw").

    Returns
    -------
    float
        Linearly interpolated energy in kW. numpy.interp clamps out-of-range values.
    """
```
</interfaces>
</context>

<feature>
  <name>interpolate_energy — linear interpolation against Part 2 lookup tables</name>
  <files>src/data/processing.py, tests/test_interpolate_energy.py</files>
  <behavior>
    Core behavior (use numpy.interp — same as interpolate_battery_cost pattern):

    With a TDS lookup where rows span 0-1900 PPM in 100-unit steps:
    - interpolate_energy(0, tds_df, "tds_ppm", "ro_energy_kw")    → float equal to row 0 y value (no extrapolation below)
    - interpolate_energy(1900, tds_df, "tds_ppm", "ro_energy_kw") → float equal to row 19 y value (no extrapolation above)
    - interpolate_energy(950, tds_df, "tds_ppm", "ro_energy_kw")  → float, midpoint between row 9 and row 10 y values
    - interpolate_energy(100, tds_df, "tds_ppm", "ro_energy_kw")  → float equal to row 1 y value exactly (on-row lookup)
    - interpolate_energy(-50, tds_df, "tds_ppm", "ro_energy_kw")  → same as value=0 (numpy.interp clamps below)
    - interpolate_energy(2000, tds_df, "tds_ppm", "ro_energy_kw") → same as value=1900 (numpy.interp clamps above)
    - Return type is always float, not numpy scalar

    Same behavior applies symmetrically for depth_lookup with col_x="depth_m", col_y="pump_energy_kw".

    Test setup: Build minimal synthetic DataFrames in the test (do NOT read data.xlsx):
    - tds_df: 20 rows, tds_ppm=[0,100,...,1900], ro_energy_kw=[0,10,...,190] (linear for easy math)
    - depth_df: same pattern with depth_m / pump_energy_kw columns
  </behavior>
  <implementation>
    After tests pass:
    - Add interpolate_energy() to src/data/processing.py after the existing interpolate_battery_cost() function
    - Mirror the numpy.interp pattern from interpolate_battery_cost()
    - Use pd.to_numeric with errors="coerce" on both x and y columns (consistent with codebase style)
    - Return float() around np.interp result (not a numpy scalar)
    - Add function to the module docstring Exports list at the top of processing.py
  </implementation>
</feature>

<verification>
Run: cd "C:/Users/kevin/Downloads/Desalination Project Vibe Code" && python -m pytest tests/test_interpolate_energy.py -v

All tests GREEN. No import errors. interpolate_energy importable from src.data.processing.
</verification>

<success_criteria>
- tests/test_interpolate_energy.py exists with at least 6 test cases covering boundary, midpoint, on-row, and clamping behaviors
- All tests pass: python -m pytest tests/test_interpolate_energy.py -v exits 0
- interpolate_energy is importable: python -c "from src.data.processing import interpolate_energy; print('OK')" exits 0
- Function signature matches: (value: float, lookup_df: pd.DataFrame, col_x: str, col_y: str) -> float
</success_criteria>

<output>
After completion, create `.planning/phases/08-parameter-sliders/08-01-SUMMARY.md`
</output>
