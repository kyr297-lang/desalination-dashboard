---
phase: 02-system-selection-and-scorecard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config.py
  - src/data/processing.py
autonomous: true
requirements:
  - SCORE-01
  - SCORE-02

must_haves:
  truths:
    - "Scorecard metric values (total cost, total land area, total energy) can be computed from the raw DataFrames"
    - "RAG color assignment (green/red for 2 systems, green/yellow/red for 3) is deterministic and correct"
    - "Cost values display as abbreviated strings ($42.5K, $1.2M)"
    - "Every equipment item has a process stage assignment and a text description"
  artifacts:
    - path: "src/data/processing.py"
      provides: "Formatting helpers, RAG logic, scorecard computation"
      exports: ["fmt_cost", "fmt_num", "fmt", "rag_color", "compute_scorecard_metrics"]
    - path: "src/config.py"
      provides: "PROCESS_STAGES mapping, EQUIPMENT_DESCRIPTIONS dict, RAG_COLORS"
      contains: "PROCESS_STAGES"
  key_links:
    - from: "src/data/processing.py"
      to: "src/config.py"
      via: "imports RAG_COLORS"
      pattern: "from src\\.config import RAG_COLORS"
    - from: "src/data/processing.py"
      to: "pandas DataFrames"
      via: "pd.to_numeric(errors='coerce') for safe aggregation"
      pattern: "pd\\.to_numeric.*errors.*coerce"
---

<objective>
Create the data processing layer and domain configuration for Phase 2: number formatting helpers, RAG color logic, scorecard metric computation, process stage mappings, and equipment descriptions.

Purpose: All UI components in Plan 02 depend on these helpers and config data. Separating data logic from layout ensures testability and avoids bloating UI modules.
Output: src/data/processing.py with all computation/formatting functions; src/config.py extended with PROCESS_STAGES and EQUIPMENT_DESCRIPTIONS dicts.
</objective>

<execution_context>
@C:/Users/kevin/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-system-selection-and-scorecard/02-RESEARCH.md
@src/config.py
@src/data/loader.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add process stage mappings and equipment descriptions to config.py</name>
  <files>src/config.py</files>
  <action>
Append two new dicts to the existing src/config.py (do NOT remove existing SYSTEM_COLORS, RAG_COLORS, or DATA_FILE):

1. **PROCESS_STAGES** — maps system key + stage name to list of equipment name strings. The equipment names MUST match exactly what appears in column B of data.xlsx (as returned by loader.py). To get the exact names, run the loader and print the "name" column for each system DataFrame.

Structure:
```python
PROCESS_STAGES = {
    "mechanical": {
        "Water Extraction": [...],
        "Pre-Treatment": [...],
        "Desalination": [...],
        "Post-Treatment": [...],
        "Brine Disposal": [...],
    },
    "electrical": {
        "Water Extraction": [...],
        "Pre-Treatment": [...],
        "Desalination": [...],
        "Post-Treatment": [...],
        "Brine Disposal": [...],
    },
}
```

Assign each equipment item to the most appropriate stage based on its function in the desalination process. If an item does not fit neatly, use best judgment. Every equipment name from the DataFrame MUST appear in exactly one stage. Add an "Other" stage only if absolutely necessary.

2. **EQUIPMENT_DESCRIPTIONS** — maps equipment name (string) to a 1-2 sentence technical description. Cover all equipment items from both mechanical and electrical systems. Descriptions should be factual and educational (audience: engineering students). Example: "Reverse Osmosis Membrane": "Semi-permeable membrane that separates dissolved salts from water under high pressure. The primary desalination component in both mechanical and electrical systems."

To discover the exact equipment names: run `python -c "from src.data.loader import load_data; d = load_data(); print(list(d['mechanical']['name'])); print(list(d['electrical']['name'])); print(list(d['miscellaneous']['name']))"` and use those exact strings as dict keys.
  </action>
  <verify>
Run: `python -c "from src.config import PROCESS_STAGES, EQUIPMENT_DESCRIPTIONS; print('Stages:', {k: {s: len(v) for s,v in stages.items()} for k, stages in PROCESS_STAGES.items()}); print('Descriptions:', len(EQUIPMENT_DESCRIPTIONS), 'items')"`
Confirm: No import errors, all equipment names covered, descriptions dict has entries for every mechanical and electrical equipment item.
  </verify>
  <done>PROCESS_STAGES maps every mechanical and electrical equipment item to exactly one of the 5 process stages. EQUIPMENT_DESCRIPTIONS has a 1-2 sentence description for every equipment item across all systems.</done>
</task>

<task type="auto">
  <name>Task 2: Create processing.py with formatting helpers, RAG logic, and scorecard computation</name>
  <files>src/data/processing.py</files>
  <action>
Create src/data/processing.py with these functions:

1. **fmt_cost(value) -> str** — Format numeric cost as abbreviated string. Rules: >= 1M → "$X.XM", >= 1K → "$X.XK", < 1K → "$X,XXX". Non-numeric or None → "N/A". Use pd.to_numeric(value, errors="coerce") for safe conversion.

2. **fmt_num(value) -> str** — Format general numeric value with 1 decimal and comma separators. Non-numeric → str(value). None → "N/A".

3. **fmt(value) -> str** — Pass-through: numeric → comma-formatted integer, string → as-is, None → "N/A".

4. **rag_color(values: dict[str, float], metric: str) -> dict[str, str]** — Compute RAG ranking. Parameters: values = {system_key: numeric_value}, metric = metric name. Define two sets: RAG_BETTER_IS_LOWER = {"cost", "land_area", "efficiency"} (efficiency here means total energy — lower energy = more efficient). Sort systems by value. With 2 systems: best = "green", worst = "red". With 3 systems: best = "green", middle = "yellow", worst = "red". Exclude None values from ranking.

5. **compute_scorecard_metrics(mechanical_df, electrical_df) -> dict** — Compute aggregate metrics per system. For each DataFrame: sum cost_usd (via pd.to_numeric coerce), sum land_area_m2 (via pd.to_numeric coerce), sum energy_kw (via pd.to_numeric coerce). Return: {"mechanical": {"cost": X, "land_area": Y, "efficiency": Z}, "electrical": {...}}. "efficiency" key holds total energy (kW) — lower is better. Label clarity is handled in the UI, not here.

6. **get_equipment_stage(equipment_name: str, system: str) -> str** — Look up process stage for an equipment item. Import PROCESS_STAGES from config. Iterate stages to find which contains the name. Return stage name or "Other" if not found.

Import RAG_COLORS from src.config where needed (for make_rag_dot if included, or leave that to the UI layer).

Do NOT import from layout modules. This is a pure data/logic module.
  </action>
  <verify>
Run: `python -c "
from src.data.loader import load_data
from src.data.processing import fmt_cost, fmt_num, fmt, rag_color, compute_scorecard_metrics, get_equipment_stage
d = load_data()
scores = compute_scorecard_metrics(d['mechanical'], d['electrical'])
print('Mechanical cost:', fmt_cost(scores['mechanical']['cost']))
print('Electrical cost:', fmt_cost(scores['electrical']['cost']))
rag = rag_color({k: v['cost'] for k,v in scores.items()}, 'cost')
print('RAG colors:', rag)
print('Stage test:', get_equipment_stage(d['mechanical']['name'].iloc[0], 'mechanical'))
"`
Confirm: Costs formatted as $X.XK or $X.XM, RAG assigns green to lower cost and red to higher, stage lookup returns a valid stage name.
  </verify>
  <done>processing.py exports all 6 functions. fmt_cost produces abbreviated dollar strings. rag_color correctly assigns green to the best system and red to the worst for each metric. compute_scorecard_metrics returns valid numeric aggregates from the DataFrames. get_equipment_stage returns the correct process stage for any equipment item.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.config import PROCESS_STAGES, EQUIPMENT_DESCRIPTIONS, SYSTEM_COLORS, RAG_COLORS"` — no import errors, all 4 dicts accessible
2. `python -c "from src.data.processing import fmt_cost, rag_color, compute_scorecard_metrics"` — no import errors
3. Scorecard values are non-zero positive numbers for both systems
4. RAG assigns exactly one color per system per metric
5. Every equipment name from loader appears in PROCESS_STAGES and EQUIPMENT_DESCRIPTIONS
</verification>

<success_criteria>
- src/data/processing.py exists with 6 exported functions
- src/config.py has PROCESS_STAGES and EQUIPMENT_DESCRIPTIONS alongside existing constants
- All formatting, RAG, and scorecard functions produce correct output when given real data from load_data()
- No new packages installed (pure Python + pandas)
</success_criteria>

<output>
After completion, create `.planning/phases/02-system-selection-and-scorecard/02-01-SUMMARY.md`
</output>
